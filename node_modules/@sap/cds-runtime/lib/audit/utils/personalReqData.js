const getTemplate = require('../../common/utils/template')
const templateProcessor = require('../../common/utils/templateProcessor')

const _hasPersonalDataAnnotation = entity => {
  const allowedAnnotations = ['DataSubject', 'DataSubjectDetails', 'Other']
  return (
    entity['@PersonalData.DataSubjectRole'] &&
    entity['@PersonalData.EntitySemantics'] &&
    allowedAnnotations.includes(entity['@PersonalData.EntitySemantics'])
  )
}

// REVISIT: Flat for each field access. Clarify how to group for audit logging and rewrite correspondingly.
const addPersonalInfo = (event, param, oldVal, newVal, keys, entity, personalInfo) => {
  personalInfo.push({
    event,
    param,
    entity,
    keys,
    oldVal,
    newVal
  })
}

const _getKeys = (row, keys) => {
  const keyObj = {}
  Object.keys(keys).forEach(key => {
    keyObj[key] = row[key]
  })

  return keyObj
}

const _pickRead = (element, target) => {
  return element['@PersonalData.IsPotentiallySensitive'] && _hasPersonalDataAnnotation(target)
}

const _pickWrite = (element, target) => {
  return (
    (element['@PersonalData.IsPotentiallyPersonal'] || element['@PersonalData.IsPotentiallySensitive']) &&
    _hasPersonalDataAnnotation(target)
  )
}

const _processorFnRead = personalInfo => {
  return (row, param, element) => {
    const val = row[param]
    if (val !== undefined && val !== null) {
      addPersonalInfo(
        'read',
        param,
        undefined,
        undefined,
        _getKeys(row, element.parent.keys),
        element.parent.name,
        personalInfo
      )
    }
  }
}

const _processorFnWrite = personalInfo => {
  return (row, param, element) => {
    let oldVal, newVal, state
    switch (row._op) {
      case 'delete':
        oldVal = row._old && row._old[param]
        newVal = null
        state = oldVal !== undefined && oldVal !== null
        break
      case 'update':
        oldVal = row._old[param]
        newVal = row[param]
        state = oldVal !== newVal
        break
      case 'create':
        oldVal = null
        newVal = row[param]
        state = newVal !== undefined && newVal !== null
        break
    }

    if (state) {
      addPersonalInfo(
        row._op,
        param,
        oldVal,
        newVal,
        _getKeys(row, element.parent.keys),
        element.parent.name,
        personalInfo
      )
    }
  }
}

const getReadAccessInfo = (data, req) => {
  const template = getTemplate(
    'personal_read',
    Object.assign({ name: req.target._service.name, model: req._model }),
    req.target,
    {
      pick: _pickRead
    }
  )

  const personalInfo = []
  const processFn = _processorFnRead(personalInfo)
  const data_ = Array.isArray(data) ? data : [data]
  data_.forEach(row => {
    templateProcessor({ processFn, row, template })
  })

  return personalInfo
}

const getWriteAccessInfo = async req => {
  const template = getTemplate(
    'personal_write',
    Object.assign({ name: req.target._service.name, model: req._model }),
    req.target,
    {
      pick: _pickWrite
    }
  )

  const personalInfo = []
  const processFn = _processorFnWrite(personalInfo)
  // REVISIT: consider re-using template instead of a flag
  Object.defineProperty(req.query, '_selectAll', {
    enumerable: false,
    writable: false,
    configurable: true,
    value: true
  })
  templateProcessor({ processFn, row: await req.diff(), template })

  return personalInfo
}

module.exports = { getWriteAccessInfo, getReadAccessInfo }
