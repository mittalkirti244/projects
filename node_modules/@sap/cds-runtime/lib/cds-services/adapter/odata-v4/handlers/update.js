const cds = require('../../../../cds')
const { SELECT, UPDATE } = cds.ql
const ODataRequest = require('../ODataRequest')

const {
  Components: { DATA_UPDATE_HANDLER, DATA_CREATE_HANDLER }
} = require('../okra/odata-server')

const { getSapMessages } = require('../../../../common/error/frontend')
const { validateResourcePath } = require('../utils/request')
const { isReturnMinimal } = require('../utils/handlerUtils')
const { foreignKeyPropagations } = require('../../../../common/utils/foreignKeyPropagations')
const readAfterWrite = require('../utils/readAfterWrite')
const { toODataResult, getVirtualsFromResult, postProcess } = require('../utils/result')

const { COMMON, ODATA } = require('../../../../common/constants/annotation')

const _isDraftEntity = target => {
  return (
    target &&
    (target[ODATA.DRAFT] || target[COMMON.DRAFT_NODE.PREP_ACTION] || target.name.endsWith('.DraftAdministrativeData'))
  )
}

const _isUpsertAllowed = target => {
  return !(cds.env.runtime && cds.env.runtime.allow_upsert === false) && !_isDraftEntity(target)
}

const _infoForeignKeyInParent = (req, odataReq, odataRes, tx) => {
  const info = {}
  // keys not in data
  if (Object.keys(req.target.keys).some(key => Object.keys(req.data).includes(key))) {
    return info
  }

  req = new ODataRequest(DATA_CREATE_HANDLER, tx, odataReq, odataRes, true)
  const nav = req.query.INSERT.into.ref && req.query.INSERT.into.ref.length !== 0 && req.query.INSERT.into.ref[1]
  const parent = req.query.INSERT.into.ref && req.query.INSERT.into.ref[0].id

  // not a navigation
  if (!parent || !nav) {
    return info
  }

  const navID = typeof nav === 'string' ? nav : nav.id
  const elementNav = tx.model.definitions[parent].elements[navID]

  // not a containment
  if (!elementNav['@odata.contained']) {
    return info
  }

  const where = req.query.INSERT.into.ref[0].where
  return { parent, nav, where }
}

const _getParentKey = (parentKeyObj, parentKey, childKey, req) => {
  let parentKeyVal, parentUpdateRequired

  if (parentKeyObj.length !== 0 && parentKeyObj[0][parentKey] !== null) {
    parentKeyVal = parentKeyObj[0][parentKey]
  } else if (req.target.keys[childKey].type === 'cds.UUID') {
    parentUpdateRequired = true
    parentKeyVal = cds.utils.uuid()
  } else {
    throw new Error('Only keys of type UUID can be generated: ' + childKey)
  }

  return { parentKeyVal, parentUpdateRequired }
}

const _create = async (req, odataReq, odataRes, tx) => {
  let result

  const { parent, nav, where } = _infoForeignKeyInParent(req, odataReq, odataRes, tx)
  if (parent && nav && where) {
    const onKeys = foreignKeyPropagations(tx.model.definitions[parent].elements[nav])
    const parentKeys = onKeys.map(key => key.parentFieldName)
    const parentKeyObj = await tx.run(SELECT.from(parent).columns(parentKeys).where(where))

    const parentUpdateObj = {}
    onKeys.forEach(key => {
      const { parentKeyVal, parentUpdateRequired } = _getParentKey(
        parentKeyObj,
        key.parentFieldName,
        key.childFieldName,
        req
      )
      odataReq.getBody()[key.childFieldName] = parentKeyVal

      if (parentUpdateRequired) {
        parentUpdateObj[key.parentFieldName] = parentKeyVal
      }
    })

    odataRes.setStatusCode(201)
    req = new ODataRequest(DATA_CREATE_HANDLER, tx, odataReq, odataRes, true)
    result = await tx.dispatch(req)

    if (Object.keys(parentUpdateObj).length !== 0) {
      await tx.run(UPDATE(parent).set(parentUpdateObj).where(where))
    }
  } else {
    req = new ODataRequest(DATA_CREATE_HANDLER, tx, odataReq, odataRes, true)
    result = await tx.dispatch(req)
  }

  return [result, req]
}

const _updateThenCreate = async (req, odataReq, odataRes, tx) => {
  let result

  try {
    result = await tx.dispatch(req)
  } catch (e) {
    if (e.code === 404 && _isUpsertAllowed(req.target)) {
      // REVISIT: remove error (and child?) from tx.context? -> would require a unique req.id
      ;[result, req] = await _create(req, odataReq, odataRes, tx)
    } else {
      throw e
    }
  }

  return [result, req]
}

const _postProcess = (odataReq, req, result, service) => {
  postProcess(req, result, service)
}

/**
 * The handler that will be registered with odata-v4.
 *
 * In case of success it calls next with the number of updated entries as result.
 * In case of error it calls next with error.
 *
 * @param {Service} service
 * @param {object} options
 * @returns {Function}
 */
const update = (service, options) => {
  return async (odataReq, odataRes, next) => {
    let req
    try {
      validateResourcePath(odataReq, options, service.model)
      req = new ODataRequest(DATA_UPDATE_HANDLER, service, odataReq, odataRes)
    } catch (e) {
      return next(e)
    }

    let tx
    const changeset = odataReq.getAtomicityGroupId()
    if (changeset) {
      tx = odataReq.getBatchApplicationData().txs[changeset]
    } else {
      cds.context = tx = service.tx(req)
    }

    // putting a property?
    const primitive = odataReq.getUriInfo().getLastSegment().getKind() === 'PRIMITIVE.PROPERTY'

    let result, err, commit
    try {
      // try UPDATE and, on 404 error, try CREATE
      ;[result, req] = await _updateThenCreate(req, odataReq, odataRes, tx)

      if (!isReturnMinimal(req)) {
        // REVISIT: find better solution
        if (!primitive && req._.readAfterWrite) {
          const dataInDb = await readAfterWrite(req, service)
          // REVISIT: may be a problem on direct update of a property (which we don't support yet)
          // augment data in db so values of virtual properties are kept
          const virtuals = getVirtualsFromResult(req.target, result)
          result = Object.assign(dataInDb[0] || result, virtuals)
        }

        _postProcess(odataReq, req, result, service)
      }

      if (!changeset) {
        commit = true
        await tx.commit(result)
      } else {
        // for passing into commit
        odataReq.getBatchApplicationData().results[changeset].push({ result, req })
      }

      if (isReturnMinimal(req)) {
        odataRes.setStatusCode(204)
      }
    } catch (e) {
      err = e
      if (!changeset && !commit) {
        // ignore rollback error, which should never happen
        await tx.rollback(e).catch(() => {})
      } else if (changeset) {
        // for passing into rollback
        odataReq.getBatchApplicationData().errors[changeset].push({ error: e, req })
      }
    } finally {
      req.messages && odataRes.setHeader('sap-messages', getSapMessages(req.messages, req._.req))

      if (err) next(err)
      else if (primitive && result) {
        const prop = odataReq.getUriInfo().getLastSegment().getProperty().getName()
        const res = { value: result[prop] }
        for (const k of Object.keys(result).filter(k => k.match(/^\*/))) res[k] = result[k]
        next(null, res)
      } else next(null, toODataResult(result))
    }
  }
}

module.exports = update
