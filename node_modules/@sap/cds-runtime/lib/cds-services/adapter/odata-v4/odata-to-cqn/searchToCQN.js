const odata = require('../okra/odata-server')
const { BINARY, LITERAL, UNARY } = odata.uri.Expression.ExpressionKind
const { getFeatureNotSupportedError } = require('../../../util/errors')

const _getExpressionKindName = kind => {
  for (const key in odata.uri.Expression.ExpressionKind) {
    if (odata.uri.Expression.ExpressionKind[key] === kind) {
      return key
    }
  }

  return 'unknown'
}

const _convertSearchTermToCqn = searchTerm => {
  if (Array.isArray(searchTerm)) {
    return searchTerm.map(element => {
      if (element === 'and' || element === 'or' || element === 'not') {
        return element
      }

      return { val: element }
    })
  }

  return [{ val: searchTerm }]
}

const _searchRecursive = search => {
  switch (search.getKind()) {
    case BINARY: {
      const operator = search.getOperator().toLowerCase()
      const left = _searchRecursive(search.getLeftOperand())
      const right = _searchRecursive(search.getRightOperand())
      return [...left, operator, ...right]
    }
    case LITERAL:
      return [`${search.getText()}`]
    case UNARY:
      return [search.getOperator(), `${search.getOperand().getText()}`]
    default:
      throw getFeatureNotSupportedError(`Search expression "${_getExpressionKindName(search.getKind())}"`)
  }
}

/**
 * Convert an OData search expression into a search CQN expression.
 *
 * @param {import('../okra/odata-commons/uri/Expression')} search - search expression
 * @throws Error in case of any other expressions than BINARY, UNARY and LITERAL
 * @returns {Array<object>} cqn - Partial cqn to be used as input param in .where or .and of SELECT
 */
const searchToCQN = search => {
  switch (search.getKind()) {
    case BINARY: {
      const leftOperand = _searchRecursive(search.getLeftOperand())
      const operator = search.getOperator().toLowerCase()
      const rightOperand = _searchRecursive(search.getRightOperand())
      const searchTerm = [...leftOperand, operator, ...rightOperand]
      const cqn = _convertSearchTermToCqn(searchTerm)
      return cqn
    }

    case LITERAL: {
      const searchTerm = `${search.getText()}`
      const cqn = _convertSearchTermToCqn(searchTerm)
      return cqn
    }

    case UNARY: {
      const searchTerm = _searchRecursive(search)
      return _convertSearchTermToCqn(searchTerm)
    }

    default:
      throw getFeatureNotSupportedError(`Search expression "${_getExpressionKindName(search.getKind())}"`)
  }
}

module.exports = searchToCQN
