const cds = require('../cds')
const LOG = cds.log('messaging')
const ExternalMessagingService = require('./ExternalMessagingService.js')
const { queueName } = require('./common-utils/naming-conventions')
const optionsApp = require('../common/utils/vcap.js')

// We could have used placeholders '+/+/+' for the first three segments
const _wildcarded = topic => topic.replace(/.*?\/.*?\/.*?\//, '+/+/+/')

class AMQPWebhookMessaging extends ExternalMessagingService {
  async init() {
    this.optionsApp = optionsApp
    if (this.options.queue) {
      const queueConfig = { ...this.options.queue }
      delete queueConfig.name
      if (Object.keys(queueConfig).length) this.queueConfig = queueConfig
    }
    this.queueName = queueName(this.options, this.optionsApp)

    cds.once('listening', () => {
      this.startListening()
    })

    return super.init()
  }

  async emit(event, ...etc) {
    const msg = this.message4(event, ...etc)
    const client = this.getClient()
    await this.queued(() => {})()
    return client.emit(msg)
  }

  startListening() {
    if (this.subscribedTopics.size) {
      const management = this.getManagement()
      this.queued(management.createQueueAndSubscriptions.bind(management))()
      this.queued(this.listenToClient.bind(this))(async (_topic, _payload, _other, { done, failed }) => {
        const event = this.subscribedTopics.get(_topic) || this.subscribedTopics.get(_wildcarded(_topic))

        const data = _payload.data
        const headers = { ..._payload }
        delete headers.data
        const msg = {
          event,
          data,
          headers,
          inbound: true,
          ...(_other || {})
        }
        if (!msg._) msg._ = {}
        msg._.topic = _topic
        try {
          await super.emit(msg)
          done()
        } catch (e) {
          failed()
          LOG._error && LOG.error(e)
        }
      })
    }
  }

  listenToClient(cb) {
    return this.getClient().listen(cb)
  }
}

module.exports = AMQPWebhookMessaging
