const cds = require('../cds')
const declaredEvents = require('./common-utils/declaredEvents.js')
// There's currently no mechanism to detect mocked services, this is the best we can do.
class MessagingService extends cds.Service {
  init() {
    // Only for one central `messaging` service, otherwise all technical services would register themselves
    if (this.name === 'messaging') {
      // listen for all subscriptions to declared events of remote, i.e. connected services
      cds.on('subscribe', (srv, event) => {
        const declared = srv.events[event]
        if (declared && srv.name in cds.requires && !srv.mocked) {
          // we register self-handlers for declared events, which are supposed
          // to be calles by subclasses calling this.dispatch on incoming events
          this.on(declared.name, async (msg, next) => {
            const { data, headers } = msg
            await srv.tx(msg).emit({ event, data, headers, __proto__: msg })
            return next()
          })
        }
      })

      // forward all emits for all declared events of local, i.e. served services
      cds.on('serving', srv => {
        for (const declared of srv.events) {
          const event = declared.name.slice(srv.name.length + 1)
          // calls to srv.emit are forwarded to this.emit, which is expected to
          // be overriden by subclasses to write events to message channel
          srv.on(event, async (msg, next) => {
            const { data, headers } = msg
            await this.tx(msg).emit({ event: declared.name, data, headers })
            return next()
          })
        }
      })
    }

    // if outbox is switched on, decorate the emit method to actually do
    // the emit only when the request succeeded
    if (this.options.outbox) {
      const { emit } = this
      this.emit = function (...args) {
        const context = this.context || cds.context
        if (context) return context.on('succeeded', () => emit.call(this, ...args))
        return emit.call(this, ...args)
      }
    }

    const { on } = this
    this.on = function (...args) {
      if (Array.isArray(args[0])) {
        const [topics, ...rest] = args
        return topics.map(t => on.call(this, t, ...rest))
      }
      return on.call(this, ...args)
    }
  }

  emit(event, data, headers) {
    return super.emit(event instanceof cds.Event ? event : new cds.Event(this.message4(event, data, headers)))
  }

  on(event, handler) {
    if (declaredEvents.isDeclared(event)) {
      return super.on(event.name, handler)
    }
    return super.on(event, handler)
  }

  topic4(event, inbound) {
    const declared =
      typeof event === 'object' ? event : cds.model && cds.model.definitions && cds.model.definitions[event]
    if (!declared) return
    if (declared['@topic']) return `topic:${declared['@topic']}`
    return this.topicFromCsn(declared, inbound) || declared.name
  }

  event4(topic, inbound) {
    // REVISIT: Get model of context instead
    const definitions = cds.model && cds.model.definitions
    if (!definitions) return
    for (const definitionName of Object.keys(definitions)) {
      const definition = definitions[definitionName]
      if (
        definition.kind !== 'event' ||
        (definition._service &&
          ((inbound && !(declaredEvents.srvNameOfEvent(definition) in cds.requires)) ||
            (!inbound && declaredEvents.srvNameOfEvent(definition) in cds.requires)))
      )
        continue
      const _topic = this.topicFromCsn(definition, inbound)
      // TODO: needs to be normalized
      if (_topic === topic) return definitionName
    }
  }

  headers(declared) {
    const result = {}
    const type = declared['@type']
    if (type) {
      result.type = type
      result.source =
        declaredEvents.sourceOfEvent(declared) || this.defaultSource(false) || declaredEvents.defaultSource
      result.specversion = '1.0'
      result.time = new Date().toISOString()
      result.datacontenttype = 'application/json'
    }
    return result
  }

  message4(event, data, headers) {
    let declared
    if (declaredEvents.isDeclared(event)) {
      declared = event
      event = event.name
    }
    const msg = typeof event === 'object' ? event : { event, data, headers: { ...headers } }
    if (declaredEvents.isDeclared(msg.event)) {
      declared = msg.event
      msg.event = msg.event.name
    }
    if (!msg.headers) msg.headers = {}
    if (!msg.inbound) {
      declared = declared || (cds.model && cds.model.definitions[msg.event]) || this.event4(msg.event, false)
      if (!msg.headers.id) msg.headers.id = cds.utils.uuid()
      if (!msg.headers['x-correlation-id'] && cds.context) msg.headers['x-correlation-id'] = cds.context.id
      if (declared) msg.headers = { ...this.headers(declared), ...msg.headers }
      this.adjustOutboundMsg(msg, declared)
    }
    return msg
  }

  adjustOutboundMsg(msg, declared) {}
  topicFromCsn(declared, inbound) {}
  defaultSource(inbound) {}
}

module.exports = MessagingService
